#lang racket

#|
ZB language
z in Z
b in B
e,f ::= z
      | b
      | (+ e e)
      | (div e e)
      | (<= e e)
      | (if e e e)
      | the-input

This is the programming language, the thing that you write down to write programs. This is a
context-free grammar that tells you the shape of your language.

τ, σ ::= Int
       | Bool

This is also a programming language, that allow us to think about our other programming
language. It's a way to write down thoughts.

Notes:
 ::= means "is one of"
 | means "or"
 |- means "proves"

Possible errors:
 - division by 0
 - <=, +, / on b

Note: div gives us integer division, making division closed in Z for this language

Bad expressions:
 (/ 5 0)
 (<= 5 #t)

Good expressions:
 (+ 5 5)
 (+ the-input 5)

? expressions:
 (/ 5 the-input)
 (/ (if (<= the-input 10) 1 #t) 3)
 (if (<= the-input 0) (+ #t 0) 42)

|- e : τ     <-- called a judgement, means the expresssion e has type τ OR it is provable that
                 the expression e has type τ
|- #f : Bool
|- (+ the-input 5) : Int
|- #t : Int

Being compositional means that we only ever look at expression's types and not their values
when type checking.

The meaning of Int means you get either an integer or an error. Same for Bool.

Our type system does not allow use to talk about anything other than Int or Bool. If a
sentence can't say either of those things, we can say nothing.

"|- e : Bool" means (eval e) either errors or produces a Bool
"       Int"                                             Int

premise
premise
__________
conclusion


__________         ___________        __________________
|- z : Int         |- b : Bool        |- the-input : Int


Look in the notes for these logical inference rules.

With the type system and these rules, we have ruled out the errors generated by
<=, +, / on b.

|- e1 : τ
|- e2 : Int
|- e3 : Int
______________________
|- (if e1 e2 e3) : Int

static and dynamic semantics

Instead of writing the above rule by replacing Int with Bool, we can write the more
general rule:

|- e1 : τ
|- e2 : σ
|- e3 : σ
____________________
|- (if e1 e2 e3) : σ

When you two meta-variables (such as here with τ and σ), they are allowed to be the same type.

Theorem: (Type Saftey)
If |- e : τ, then (eval e) can signal only one error: division by 0.

Let's start adding variables.

f,e ::= ...                  <--- the dots just mean we're extending our previous expressions
      | x
      | (let ([x e1]) e2)

We need an environment now.

Γ ::= 0
    | Γ,x : τ

Now, we need to extend our judgement (the sentences we can write).

Γ |- e : τ

Let's add functions.

f,e ::= ...
      | (λ (x ...) e)        <--- function
      | (e0 ei ...)          <--- application

We now need to extend our type system.

τ, σ ::= Int
       | Bool
       | (-> σ ... τ)

V    V   ^
Γ |- e : τ

In the inference rule for λ, the input variable types sort of come from nowhere. We know they
need to have types, but what exact types? Thus, we need to extend the language to have the types
specified inside the λ expression. The variables inside the input arguments for λ do not see
the external environment.

Thus, we have:

f,e ::= ...
      | (λ ([x σ] ...) e)

We are going to be doing local inference, called bi-directional type inference.

V    V    ^
Γ |- e => τ        <--- compute judgement

V    V    V
Γ |- e <= τ        <--- check judgement

|#